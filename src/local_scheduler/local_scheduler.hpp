// Author: Dai Wei (wdai@cs.cmu.edu)
// Date: 2013.11.18

#ifndef PETUUM_LOCAL_SCHEDULER
#define PETUUM_LOCAL_SCHEDULER

#include "local_scheduler/delta_sampler.hpp"
#include "common/blocking_queue.hpp"
#include <boost/scoped_ptr.hpp>
#include <boost/thread/thread.hpp>
#include <boost/thread.hpp>
#include <semaphore.h>
#include <atomic>

namespace petuum {

// LocalSchedulerTask is generated by LocalScheduler and pushed to application
// thread to execute.
struct LocalSchedulerTask {
  int32_t task_id;
  LocalSchedulerTask() : task_id(0) { }
  LocalSchedulerTask(int32_t id) : task_id(id) { }
};

// LocalSchedulerTaskResult is generated by application threads and passed to
// scheduler for next round.
struct LocalSchedulerTaskResult {
  int32_t task_id;
  float weight;
  LocalSchedulerTaskResult(int32_t id, float w) : task_id(id), weight(w) { }
};

struct LocalSchedulerConfig {
  // Capacity of the pending_task_q_ and result_q_ in LocalScheduler.
  int32_t queue_capacity;
};

//     +-----+ --- scheduler thread <--+-----+
//     |                                     ^
//     |                                     |
//     v                                     |
// pending_task_q_                      result_q_
//     |                                     ^
//     |                                     |
//     |                                     |
//     v              scheduler              |
// ================================================
//     |             application             ^
//     |                                     |
//     |                                     |
//     |     +--> application thread ---+    |
//     +-----+--> application thread ---+----+
//           +--> application thread ---+
//
// Note that all public methods in LocalScheduler are thread safe.
//
// Comment(wdai): The task pool size needs to be greater than the size of
// pending_task_q_ in order for the scheduler to cleanly shutdown.
//
// Comment(wdai): The task ID cannot be SHUTDOWN_TASK_ID, which triggers
// shutdown procedures.
class LocalScheduler {
  public:
    explicit LocalScheduler(const LocalSchedulerConfig& config);
    ~LocalScheduler();

    // Add a task to initial_tasks_, which will be emptied after first round.
    // Note that task_id is assumed to be unique.
    void AddTask(int32_t task_id);

    // Application threads calls GetTask() to get a task. Note that it will
    // block until StartScheduler() is called.
    LocalSchedulerTask GetTask();

    // Application threads returns the result of computing the task.
    void ReturnResult(LocalSchedulerTaskResult result);

    // Starts two threads: generator_thread_ pushes task to pending_task_q_
    // using GenerateTask(); collector_thread_ consumes from result_q_ and add
    // the items back to DeltaSampler with the result computed from
    // applications using CollectResult(). Note that StartScheduler() is
    // idempotent and thread safe.
    void StartScheduler();

    // Terminate generator_thread_ and collector_thread_. It's thread safe and
    // idempotent.
    void ShutDown();

    static const int32_t SHUTDOWN_TASK_ID;

  private:  // private functions
    // Produce a task and push to pending_task_q_ if it is not full; block
    // if it is full. Initially the tasks are taken from initial_tasks_, but
    // after initial_tasks_ becomes empty it produces from delta_sampler_.
    void GenerateTask();

    // Consume a result from result_q_ and add to delta_sampler_.
    void CollectResult();

  private:  // private members
    LocalSchedulerConfig config_;

    // Queue of tasks generated by LocalScheduler but not yet consumed by
    // workers. See ASCII art at the top.
    boost::scoped_ptr<BlockingQueue<LocalSchedulerTask> > pending_task_q_;

    // Results coming back from the workers. See ASCII art at the top.
    boost::scoped_ptr<BlockingQueue<LocalSchedulerTaskResult> > result_q_;

    DeltaSampler delta_sampler_;

    // All tasks are sequentially sent out in the first round. The results
    // will return to delta_sampler_ instead of initial_tasks_ (i.e.,
    // initial_tasks_ will be emptied after the first round). Afterwards
    // delta_sampler_ will take over.
    std::list<int32_t> initial_tasks_;

    // Total number of tasks; used as sem_task_pool_size_'s initial count.
    int num_tasks_;

    // sem_task_pool_size_ ensures that there is at least one task in the
    // pool when GenerateTask is called. It starts with num_tasks_;
    // GenerateTask decrements (sem_wait) sem_task_pool_size_ while
    // CollectResult() increments (sem_post) it.
    sem_t sem_task_pool_size_;

    // True when shutdown is initiated.
    std::atomic<bool> shutdown_generator_;

    // scheduler_started_ and shutting_down_ makes StartScheduler() and
    // ShutDown() // idempotent.
    bool scheduler_started_;
    bool shutting_down_;

    // Make all methods thread safe.
    boost::mutex global_mutex_;

    // The two background threads.
    boost::scoped_ptr<boost::thread> generator_thread_;
    boost::scoped_ptr<boost::thread> collector_thread_;
};

}  // namespace petuum

#endif  // PETUUM_LOCAL_SCHEDULER
